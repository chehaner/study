#### 手写深拷贝
```javascript
function deepClone(obj, map = new WeakMap()) {
    //基本对象直接返回
    if (obj === null || typeof(obj) !== 'object') {
        return obj;
    }
    let cloneObj;
    //处理缓存
    if (map.has(obj)) {
        return map.get(obj);
    }
    //拷贝
    if (obj instanceof Array) {//数组
        cloneObj = [];
        obj.forEach((element) => {
            cloneObj.push(deepClone(element, map));
        });
    } else if (obj instanceof Map) {//哈希表
        cloneObj = new Map();
        obj.forEach((value, key) => {
            cloneObj.set(deepClone(key, map), deepClone(value, map));//哈希表的键可能是对象所以也要深拷贝，而普通对象不用
        });
    } else if (obj instanceof Set) {//元组
        cloneObj = new Set();
        obj.forEach((value) => {
            cloneObj.add(deepClone(value, map));
        });
    } else if (obj instanceof Object) {//普通对象
        cloneObj = {};
        for (let element in obj) {
            if (obj.hasOwnProperty(element)) {
                cloneObj[element] = deepClone(obj[element], map);//普通对象要判断是不是本身属性
            }
        }
    }
    //添加缓存
    map.set(obj, cloneObj);
    return cloneObj;
}
```
#### 手写防抖和节流
防抖
```javascript
function debounce(fn, delay){
    let timer = null;
    return function(...args){
        // 又触发了，清除之前的计时器
        if(timer){
            clearTimeout(timer);
        }
        //重新开始计时（以最后一次为准）
        timer = setTimeout(()=>{
            fn.apply(this, args);
        },delay);
    };
}
function search(query) {
    console.log(`搜索关键词: ${query}`);
}
const debouncedSearch = debounce(search, 2000);
debouncedSearch("a")
debouncedSearch("b")
debouncedSearch("c")
```
节流
```javascript
function throttling(fn, interval) {
    let lastTime = 0; // 初始化 lastTime
    return function (...args) {
        const now = Date.now();
        // 超过了间隔时间，才会执行
        if (now - lastTime >= interval) {
            fn.apply(this, args);
            lastTime = now; // 更新 lastTime
        }
        // 没有超过间隔时间继续计时
    };
}

function search(count) {
    console.log(count);
}

const throttledSearch = throttling(search, 100);

throttledSearch(1); 
setTimeout(() => throttledSearch(2), 150);
setTimeout(() => throttledSearch(3), 190);
setTimeout(() => throttledSearch(4), 250);
setTimeout(() => throttledSearch(5), 300);
```
#### 手写hardman
```javascript
class Hardman{
    constructor(name){
        this.name = name;
        this.tasks = [];
        setTimeout(()=>{
            this.next();
        }, 0);
    }
    next(){
        if(this.tasks.length>0){
            const task = this.tasks.shift();
            task();
        }
    }
    rest(time){
        this.tasks.push(()=>{
            console.log(`Resting ${time}`);
            setTimeout(()=>this.next(), time*1000);
        })
        return this;
    }
    learn(skill){
        this.tasks.push(()=>{
            console.log(`Learning ${skill}`)
            this.next();
        })
        return this;
    }
}
function hardman(name) {
  return new Hardman(name);
}
hardman('Tom').rest(2).learn('JavaScript').rest(1).learn('Vue');
```
#### 手写柯里化函数
```javascript
function curry(fn) {
    return function curried(...args) {
        // 如果传入的参数足够了，就直接调用原函数
        if (args.length >= fn.length) {
            return fn(...args);
        } else {
            // 否则，返回一个新的函数，接收更多的参数
            return function (...nextArgs) {
                return curried(...args, ...nextArgs);
            };
        }
    };
}
function sum(a, b, c) {
    return a + b + c;
}
const curriedSum = curry(sum);
console.log(sum(1,2,3));//6
console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2, 3)); // 6

```
#### 手写promise.all
```javascript
Promise.myAll = function(promises){
    // 创建一个结果Promise对象
    return new Promise((resolve, reject)=>{
        let i = 0;
        let count = 0;
        const result = [];
        for (const promise of promises){//对于迭代对象中的每一个promise
            const index = i;
            i++;
            Promise.resolve(promise).then(//先把它包装为promise
                //完成
                (data)=>{
                //一个成功
                result[index] = data;//加进结果数组
                count++;
                if(count === i){
                    resolve(result);
                }
            }, reject)//一个失败，调用结果对象失败
        }
        if(i===0){
            resolve([])
        }
    });
}
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.myAll([promise1, promise2, promise3]).then((results) => {
    console.log("Test Case 1: All promises resolved", results);
}).catch((error) => {
    console.error("Test Case 1: Unexpected error", error);
});
```
#### 串行和并行
```javascript
async function A() {
  await new Promise(resolve => setTimeout(resolve, 1000));
}
async function B() {
  await new Promise(resolve => setTimeout(resolve, 2000));
}
async function C() {
  await new Promise(resolve => setTimeout(resolve, 3000));
}
async function D() {
  await new Promise(resolve => setTimeout(resolve, 4000));
}
async function execute() {
  await A();
  await B();
  await Promise.all([C(), D()]);
}
execute();
```

#### 带并发限制的请求调度器
```javascript
function limitRequest(urls, limit, callback) {
  let index = 0; // 当前请求索引
  let count = 0; // 当前并发数量
  let results = new Array(urls.length); // 存储请求结果

  return new Promise((resolve) => {
    function next() {
      if (index >= urls.length && count === 0) {
        resolve(results); // 全部请求完成
        callback && callback(results);
        return;
      }

      while (count < limit && index < urls.length) {
        let curIndex = index; // 记录当前索引
        let url = urls[index++];
        count++;

        fetch(url)
          .then((res) => res.json()) // 假设返回 JSON 数据
          .then((data) => {
            results[curIndex] = { success: true, data };
          })
          .catch((error) => {
            results[curIndex] = { success: false, error };
          })
          .finally(() => {
            count--;
            next(); // 继续下一个请求
          });
      }
    }

    next(); // 启动请求
  });
}

// 测试
const urls = [
  "https://jsonplaceholder.typicode.com/todos/1",
  "https://jsonplaceholder.typicode.com/todos/2",
  "https://jsonplaceholder.typicode.com/todos/3",
  "https://jsonplaceholder.typicode.com/todos/4",
  "https://jsonplaceholder.typicode.com/todos/5",
];

limitRequest(urls, 2, (results) => {
  console.log("所有请求完成:", results);
});

```
#### 手写订阅发布模式
```javascript
class EventEmitter{
    constructor(){
        this.events = {};
    }
    on(eventName, callback){
        if(!this.events[eventName]){
            this.events[eventName] = [];
        }
        // 注册时，将订阅者加进事件列表，以便发布时可以触发
        this.events[eventName].push(callback);
    }
    emit(eventName, data){
        // 找找对应要触发的订阅者
        const callbacks = this.events[eventName];
        if(this.events[eventName]){
            // 可能有多个，依次触发
            callbacks.forEach((callback)=>{
                callback(data);
            })
        }
    }
    off(eventName, callback){
        // 找找对应要触发的订阅者
        const callbacks = this.events[eventName];
        // 把要销毁的订阅者删掉
        if(callbacks){
            this.events[eventName] = callbacks.filter(
                fn => fn !== callback
            )
        }
    }
}
const emitter = new EventEmitter()
const onMessage = (message) => {
    console.log(`收到消息：${message}`);
}
emitter.on('onMessage', onMessage)
emitter.emit('onMessage', '这是一条信息1')
emitter.off('onMessage', onMessage)
emitter.emit('onMessage', '这是一条信息2')
```
#### 手写require
```javascript
const fs = require('fs');
const path = require('path');
const moduleCache = {};
function myRequire(modulePath){
    const absolutePath = path.resolve(__dirname, modulePath);
    if(moduleCache[absolutePath]){
        return moduleCache[absolutePath].exports;
    }
    const moduleCode = fs.readFile(absolutePath, 'utf-8');
    const module = { exports:{} }
    moduleCAche[absolute] = module;
    const wrapperFunction = new Function('module', 'exports', 'require', moduleCode);
    wrapperFunction(module, module.exports, myRequire);
    return module.exports;
}
```
#### 手写call、bind、apply
call
```javascript
Function.prototype.myCall = function(context, ...args) {
    context = context === null || undefined ? globalThis: Object(context);// 相当于cat
    const newFn = Symbol("call");
    context[newFn] = this; // 在cat上添加一个方法，就是greet这个方法
    const res = context[newFn](...args); // 相当于cat.greet
    delete context[newFn];// 删除防止污染cat
    return res
}
function greet(food1, food2) {
    return `${this.name} 喜欢 ${food1} 和 ${food2}`;
}
const cat = { name: '咪咪' };
console.log(greet.myCall(cat, "鱼", "肉")); // this.myCall(context, ...args)
/////////////////  cat.greet("鱼"，"肉")    =>  context.this(...args)
```
#### 手写new
```javascript
function myNew(constructor, ...args) {
    if (typeof constructor !== "function") {
        throw new TypeError("constructor must be a function");
    }
    // 1. 把新对象的原型指向构造函数的 prototype
    const obj = {};
    obj.__proto__ = Object.create(constructor.prototype);
    // 2. 将 this 绑定到新对象上，执行构造函数
    const result = constructor.apply(obj, args);
    // 3. 如果构造函数返回的是对象，则返回该对象，否则返回新对象
    return result instanceof Object ? result : obj;
}
function Person(name, age) {
    this.name = name;
    this.age = age;
}
const person1 = myNew(Person, "Bob", 30);
console.log(person1.name); // Bob
console.log(person1.age); // 30
console.log(person1 instanceof Person); // true
```
#### 手写instanceof
```javascript
function myInstanceOf(left, right){
    if (left === null || left === undefined ||(typeof left !== "object")) {
        return false;
    }
    let proto = Object.getPrototypeOf(left);
    while(proto){
        if(proto === right.prototype){
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    return false;
}
console.log(myInstanceOf(123, Number))
```
#### 手写flat、对象扁平化
```javascript
/////////// flat，数组拍平
function myFlat(arr){
    let res = [];
    for(let item of arr){
        if(item instanceof Array){// 还有数组
            res = res.concat(myFlat(item));
        }else{// 已经拍平
            res.push(item);
        }
    }
    return res;
}
const arr = [1, [2, 3, [4, 5]]];
const result = myFlat(arr);
console.log(result);
//////////// FlatMap
Array.prototype.myFlatMap = function(callback) {
    let result = [];
    for (let i = 0; i < this.length; i++) {
        let mappedValue = callback(this[i], i, this);
        result = result.concat(mappedValue);
    }
    return result;
};
const arr = [1, 2, 3];
const result = arr.myFlatMap(x => [x, x * 2]);
console.log(result);  // [1, 2, 2, 4, 3, 6]
////////////// 对象扁平化
function objectFlat(obj, parentKey = '', res = {}){
    for(let key in obj){
        if(obj.hasOwnProperty(key)){
            const newKey = parentKey ? `${parentKey}.${key}` : key;
            if(typeof obj[key]==='object'){
                objectFlat(obj[key], newKey, res)// 对象和数组不一样，它没有concat，所以要传递res
            }else{
                res[newKey] = obj[key];
            }
        }
    }
    return res;
}
const source = { a: { b: { c: 1, d: 2 }, e: 3 }, f: { g: 2 } }
// { 'a.b.c': 1, 'a.b.d': 2, 'a.e': 3, 'f.g': 2 }
console.log(objectFlat(source))
```
#### 数组转树
```javascript
const arr = [
 { id: "01", name: "张⼤⼤", pid: "", job: "项⽬经理" },
 { id: "02", name: "⼩亮", pid: "01", job: "产品leader" },
 { id: "03", name: "⼩美", pid: "01", job: "UIleader" },
 { id: "04", name: "老马", pid: "01", job: "技术leader" },
 { id: "05", name: "老王", pid: "01", job: "测试leader" },
 { id: "06", name: "老李", pid: "01", job: "运维leader" },
 { id: "07", name: "⼩丽", pid: "02", job: "产品经理" },
 { id: "08", name: "⼤光", pid: "02", job: "产品经理" },
 { id: "09", name: "⼩高", pid: "03", job: "UI设计师" },
 { id: "10", name: "⼩刘", pid: "04", job: "前端⼯程师" },
 { id: "11", name: "⼩华", pid: "04", job: "后端⼯程师" },
 { id: "12", name: "⼩李", pid: "04", job: "后端⼯程师" },
 { id: "13", name: "⼩赵", pid: "05", job: "测试⼯程师" },
 { id: "14", name: "⼩强", pid: "05", job: "测试⼯程师" },
 { id: "15", name: "⼩涛", pid: "06", job: "运维⼯程师" },
];
function toTree(list, parId) {
    let len = list.length;
    function loop(parId) {
        let res = [];
        for (let i = 0; i < len; i++) {
            let item = list[i];
            if (item.pid === parId) {
                item.children = loop(item.id);
                res.push(item);
            }
        }
        return res;
    }
    return loop(parId);
}
let result = toTree(arr, "");
console.log(result);
```
#### 千分位用逗号隔开
```javascript
const thousandSeperator = function(n){
    let a = n.toString();
    let count = 0;
    let res = []
    for(let i = a.length-1; i>=0; i--){
        count++;
        if(count<=3){
            res.push(a[i])
        }else{
            res.push(",");
            res.push(a[i]);
            count = 1;
        }
    }
    return res.reverse().join("")
}
console.log(thousandSeperator(12345678))
```
#### url解析
```javascript
const url = "www.qq.com?a=1&b=2";
const query = url.split('?')[1];
const res = {};
query.split('&').forEach(ele => {
    const [key, value] = ele.split('=');
    res[key] = value;
})
console.log(res)
///////////url对象
const urlString = "www.qq.com?a=1&b=2";
const fullUrl = "https://" + urlString;
const url = new URL(fullUrl);
const params = new URLSearchParams(url.search);
const res = {};
for(const [key, value] of params.entries()){
    res[key] = value;
}
console.log(res)
```
#### 手写ajax
```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET", url, true);
xhr.onreadystatechange = function(){
    if(this.readyState !== 4)return
    if(this.status === 200){
        console.log(this.response);
    }else{
        throw new Error(xhr.statusText);
    }
}
xhr.send();
```