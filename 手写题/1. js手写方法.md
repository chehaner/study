#### 手写深拷贝
```javascript
function deepClone(obj, map = new WeakMap()) {
    //基本对象直接返回
    if (obj === null || typeof(obj) !== 'object') {
        return obj;
    }
    let cloneObj;
    //处理缓存
    if (map.has(obj)) {
        return map.get(obj);
    }
    //拷贝
    if (obj instanceof Array) {//数组
        cloneObj = [];
        obj.forEach((element) => {
            cloneObj.push(deepClone(element, map));
        });
    } else if (obj instanceof Map) {//哈希表
        cloneObj = new Map();
        obj.forEach((value, key) => {
            cloneObj.set(deepClone(key, map), deepClone(value, map));//哈希表的键可能是对象所以也要深拷贝，而普通对象不用
        });
    } else if (obj instanceof Set) {//元组
        cloneObj = new Set();
        obj.forEach((value) => {
            cloneObj.add(deepClone(value, map));
        });
    } else if (obj instanceof Object) {//普通对象
        cloneObj = {};
        for (let element in obj) {
            if (obj.hasOwnProperty(element)) {
                cloneObj[element] = deepClone(obj[element], map);//普通对象要判断是不是本身属性
            }
        }
    }
    //添加缓存
    map.set(obj, cloneObj);
    return cloneObj;
}
```

#### 手写柯里化函数
```javascript
function curry(fn) {
    return function curried(...args) {
        // 如果传入的参数足够了，就直接调用原函数
        if (args.length >= fn.length) {
            return fn(...args);
        } else {
            // 否则，返回一个新的函数，接收更多的参数
            return function (...nextArgs) {
                return curried(...args, ...nextArgs);
            };
        }
    };
}
function sum(a, b, c) {
    return a + b + c;
}
const curriedSum = curry(sum);
console.log(sum(1,2,3));//6
console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2, 3)); // 6

```

#### 手写call、bind、apply
call
```javascript
Function.prototype.myCall = function(context, ...args) {
    context = context === null || undefined ? globalThis: Object(context);// 相当于cat
    const newFn = Symbol("call");
    context[newFn] = this; // 在cat上添加一个方法，就是greet这个方法
    const res = context[newFn](...args); // 相当于cat.greet
    delete context[newFn];// 删除防止污染cat
    return res
}
function greet(food1, food2) {
    return `${this.name} 喜欢 ${food1} 和 ${food2}`;
}
const cat = { name: '咪咪' };
console.log(greet.myCall(cat, "鱼", "肉")); // this.myCall(context, ...args)
/////////////////  cat.greet("鱼"，"肉")    =>  context.this(...args)
```

#### 手写new
```javascript
function myNew(constructor, ...args) {
    if (typeof constructor !== "function") {
        throw new TypeError("constructor must be a function");
    }
    // 1. 把新对象的原型指向构造函数的 prototype
    const obj = {};
    obj.__proto__ = Object.create(constructor.prototype);
    // 2. 将 this 绑定到新对象上，执行构造函数
    const result = constructor.apply(obj, args);
    // 3. 如果构造函数返回的是对象，则返回该对象，否则返回新对象
    return result instanceof Object ? result : obj;
}
function Person(name, age) {
    this.name = name;
    this.age = age;
}
const person1 = myNew(Person, "Bob", 30);
console.log(person1.name); // Bob
console.log(person1.age); // 30
console.log(person1 instanceof Person); // true
```

#### 手写instanceof
```javascript
function myInstanceOf(left, right){
    if (left === null || left === undefined ||(typeof left !== "object")) {
        return false;
    }
    let proto = Object.getPrototypeOf(left);
    while(proto){
        if(proto === right.prototype){
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    return false;
}
console.log(myInstanceOf(123, Number))
```