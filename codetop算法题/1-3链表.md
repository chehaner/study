#### [136. LRU缓存](https://leetcode.cn/problems/lru-cache/)
```javascript
var ListNode = function(key, value){
    this.key = key;
    this.value = value;
    this.next = null;
    this.prev = null;
}

/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.capacity = capacity;  // 最大存储值
    this.curSize = 0;          // 目前长度
    this.nodeMap = {};         // 存储链表结点的map
    this.head = new ListNode(-1, -1);
    this.tail = new ListNode(-1, -1);
    this.head.next = this.tail;
    this.tail.prev = this.head;
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (this.capacity === 0) return -1; // 如果容量为0，直接返回-1
    let node = this.nodeMap[key];
    if (node) {
        this.moveToHead(node);
        return node.value;
    } else {
        return -1;
    }
};

/** 
 * @param {number} key
 * @return {void}
 */
LRUCache.prototype.moveToHead = function(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;

    node.next = this.head.next;
    this.head.next.prev = node;
    this.head.next = node;
    node.prev = this.head;
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if (this.capacity === 0) return; // 如果容量为0，什么都不做
    let node = this.nodeMap[key];
    if (node) {
        node.value = value;
        this.moveToHead(node);
    } else {
        let listNode = new ListNode(key, value);
        this.nodeMap[key] = listNode;
        this.addToHead(listNode);
    }
};

/** 
 * 添加到链表头部
 */
LRUCache.prototype.addToHead = function(node) {
    node.next = this.head.next;
    this.head.next.prev = node;
    this.head.next = node;
    node.prev = this.head;

    this.curSize++;

    if (this.curSize > this.capacity) {
        // 删除尾部的节点
        let tailNode = this.tail.prev;
        let newTailNode = this.tail.prev.prev;
        newTailNode.next = this.tail;
        this.tail.prev = newTailNode;
        // 删除哈希表中的这个节点
        delete this.nodeMap[tailNode.key];
        this.curSize--;
    }
};
```

#### [141.环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)
```javascript
var hasCycle = function(head) {
    while(head){
        if(head.flag){
            return true
        }
        head.flag = true
        head = head.next
    }
    return false
};
```

#### [BM1. 反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function ReverseList( head ) {
    let pre = null
    let cur = head
    while(cur){
        let nextTemp = cur.next
        cur.next = pre
        pre = cur
        cur = nextTemp
        //运用es6解构赋值，一一对应，不需要考虑赋值顺序，不需要定义额外next
        //[curr.next,prev,curr]=[prev,curr,curr.next]
    }
    return pre
}
```
#### [BM2. 链表内指定区间反转](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function reverseBetween( head ,  m ,  n ) {
    if (!head || m === n) return head;
    let dummy = new ListNode(0);
    //建一个虚拟节点
    dummy.next = head;
    let newHead = dummy;
    let count = n-m+1;
    //让newHead指向要反转的头的前一个
    for(let i=1; i<m; i++){
        newHead = newHead.next;
    }
    //开始反转
    let pre = null
    let cur = newHead.next 
    while(count >0){
        [cur.next, pre, cur] = [pre, cur, cur.next]
        count--
    }
    //连接头和尾
    newHead.next.next = cur;
    newHead.next = pre;
    return dummy.next;
}
```
#### [BM4. 排序两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tqId=23267&ru=%2Fpractice%2Fb58434e200a648c589ca2063f1faf58c&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function Merge( pHead1 ,  pHead2 ) {
    if(pHead1 == null) return pHead2
    if(pHead2 == null) return pHead1
    let dummy = new ListNode(0);
    let cur = dummy;
    while(pHead1 != null && pHead2 != null){
        if(pHead1.val <= pHead2.val){
            cur.next = pHead1
            pHead1 = pHead1.next
        } else{
            cur.next = pHead2
            pHead2 = pHead2.next
        }
        cur = cur.next
    }
    if (pHead1 != null) cur.next = pHead1
    if (pHead2 != null) cur.next = pHead2
    return dummy.next
}
```
#### [BM5. 合并k个已排序的链表](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=%2Fpractice%2F96bd6684e04a44eb80e6a68efc0ec6c5&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function mergeKLists( lists ) {
    let result = new ListNode(0)
    let head = result
    let flag = true
    while(flag){
        let min = 1001  
        let minIdx = -1
        flag = false
        for(let i=0; i<lists.length; i++){
            let tmp = lists[i]
            if(tmp){
                flag = true
            }else{
                continue
            }
            if(tmp.val < min){
                min = tmp.val
                minIdx = i
            }
        }
        if(minIdx != -1){
            result.next = lists[minIdx]
            result = result.next
            lists[minIdx] = lists[minIdx].next
        }
        
    }
    return head.next
}
```
#### [BM6. 判断链表中是否有环](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tqId=605&ru=%2Fpractice%2F886370fe658f41b498d40fb34ae76ff9&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
    function hasCycle( head ) {
        while(head){
            if(head.flag){
                return true
            }
            head.flag = true
            head = head.next
        }
        return false
    }
```
#### [BM7. 链表中环的入口结点](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&tqId=23449&ru=%2Fpractice%2F65cfde9e5b9b4cf2b6bafa5f3ef33fa6&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function EntryNodeOfLoop(pHead)
{
    while(pHead !== null){
        if(pHead.flag){
            return pHead
        }else{
            pHead.flag = true;
            pHead = pHead.next
        }
    }
    return null
}
```
#### [BM8. 链表中倒数最后k个结点](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=%2Fpractice%2F65cfde9e5b9b4cf2b6bafa5f3ef33fa6&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function FindKthToTail( pHead ,  k ) {
    var p1 = pHead;
    // p1 先走 k 步
    for (var i = 0; i < k; i++) {
        if(p1 == null)  return null;
        p1 = p1.next;
    }
    var p2 = pHead;
    // p1 和 p2 同时走 n - k 步
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
    return p2;
}
```
#### [BM10. 两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=295&tqId=23257&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function FindFirstCommonNode(pHead1, pHead2)
{
    while(pHead1){
        if(pHead1.flag){
            return pHead1
        }
        pHead1.flag = 1
        pHead1 = pHead1.next
    }
    while(pHead2){
        if(pHead2.flag){
            return pHead2
        }
        pHead2.flag = 1
        pHead2 = pHead2.next
    }
}
```