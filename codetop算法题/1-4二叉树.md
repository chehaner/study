#### 二叉树的层序遍历
```javascript
var levelOrder = function(root) {
    if (root == null) return []; // 空树返回空数组
    let q = [root];  // 用队列存储当前层的所有节点
    let res = [];    // 结果数组

    while (q.length) {
        let tmp = []; // 存储当前层的值
        let size = q.length; // 当前层的节点数

        for (let i = 0; i < size; i++) {
            let cur = q.shift(); // 取出队列的第一个节点
            tmp.push(cur.val);   // 存入当前层的值

            // 将左右子节点加入队列
            if (cur.left) q.push(cur.left);
            if (cur.right) q.push(cur.right);
        }

        res.push(tmp); // 把当前层的结果存入 res
    }

    return res;
};
```

#### 翻转二叉树
```javascript
var invertTree = function(root) {
    function traverse(root){
        if(root == null){
            return
        }
        let tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        traverse(root.left);
        traverse(root.right);
    }
    traverse(root);
    return root;
};
```

#### 根节点到叶结点数字和
```javascript
var sumNumbers = function(root) {
    let res = 0;
    let tmp = [];
    var traverse = function(root){
        if(!root){
            return null
        }
        tmp.push(root.val)
        if(!root.left&&!root.right){
            res = res+Number(tmp.join(""))
        }
        traverse(root.left)
        traverse(root.right)
        tmp.pop()
    }
    traverse(root)
    return res
};
```
#### 路径总和
```javascript
var hasPathSum = function(root, targetSum) {
    if (!root) return false;
    let tmp = 0;
    let found = false;
    var traverse = function(root){// 不用加targetSum
        if(!root){
            return
        }
        tmp = tmp + root.val
        if (!root.left && !root.right && tmp === targetSum) {
            found = true
        }
        traverse(root.left)
        traverse(root.right)
        tmp = tmp - root.val
    }
    traverse(root)
    return found;
};
```

#### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)
```javascript
var preorderTraversal = function(root) {
    var res = []
    var traverse = function(root){
        if(root == null){
            return;
        }
        res.push(root.val)
        traverse(root.left)
        traverse(root.right)
    }
    traverse(root)
    return res
};
```