#### [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/)
给你两个 版本号字符串 version1 和 version2 ，请你比较它们。版本号由被点 '.' 分开的修订号组成。修订号的值 是它 转换为整数 并忽略前导零。

比较版本号时，请按 从左到右的顺序 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 0。

返回规则如下：
如果 version1 < version2 返回 -1，
如果 version1 > version2 返回 1，
除此之外返回 0。
+ 方法一
  ```javascript
    var compareVersion = function(version1, version2) {
        const n = version1.length, m = version2.length;
        let i = 0, j = 0;
        while (i < n || j < m) {// 遍历i, j使其遍历完一个字符串
            let x = 0;
            for (; i < n && version1[i] !== '.'; ++i) {// 每个点号内的为一个计算点
                x = x * 10 + version1[i].charCodeAt() - '0'.charCodeAt();
            }
            ++i; // 跳过点号
            ///////////////
            let y = 0;
            for (; j < m && version2.charAt(j) !== '.'; ++j) {
                y = y * 10 + version2[j].charCodeAt() - '0'.charCodeAt();
            }
            ++j;
            if (x !== y) {
                return x > y ? 1 : -1;
            }
        }
        return 0;
    };
  ```
+ 方法二
```javascript
var compareVersion = function(version1, version2) {
    const v1 = version1.split('.');
    const v2 = version2.split('.');
    for (let i = 0; i < v1.length || i < v2.length; ++i) {
        let x = 0, y = 0;
        if (i < v1.length) {
            x = parseInt(v1[i]);
        }
        if (i < v2.length) {
            y = parseInt(v2[i]);
        }
        if (x > y) {
            return 1;
        }
        if (x < y) {
            return -1;
        }
    }
    return 0;
};
```

#### [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
```javascript
var merge = function(nums1, m, nums2, n) {
    let i = m-1, j = n-1;
    let p = nums1.length-1;
    // 原地修改nums1，所以从后面开始移动
    while(p>0&&j>=0&&i>=0){
        if(nums1[i] >= nums2[j]){
            nums1[p] = nums1[i]
            i--;
        }
        else{
            nums1[p] = nums2[j]
            j--;
        }
        p--;
    }
    //如果nums2还有的话，要把nums2剩下的加进去
    //nums1如果有剩下的，本来就在数组中
    while(j >= 0){
        nums1[p] = nums2[j];
        j--;
        p--;
    }
};
```

#### 两数之和&三数之和
两数之和
```javascript
var twoSum = function(nums, target) {
    let dic = new Map()
    for(let i=0; i<nums.length; i++){
        if(dic.has(target-nums[i])){
            return [dic.get(target-nums[i]),i]
        }
        dic.set(nums[i],i)
    }
};
```
三数之和
```javascript
var threeSum = function(nums) {
    nums.sort((a, b) => a - b)
    const ans =[];
    for(let i = 0; i<nums.length-2; i++){
        const x = nums[i];
        if(i>0&&x===nums[i-1])continue;
        let j = i+1, k = nums.length-1;
        while(j<k){
            const s = x + nums[j] +nums[k];
            if(s>0){
                k--;
            }
            else if(s<0){
                j++;
            }
            else{
                ans.push([x, nums[j], nums[k]]);
                j+=1
                while(j<k && nums[j] === nums[j-1]){
                    j+=1
                }
                k-=1
                while(k>j && nums[k] === nums[k+1]){
                    k-=1
                }
            }
        }
    }
    return ans;
};
```

#### [53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

```javascript
var maxSubArray = function(nums) {
    let left = 0;
    let result = Number.MIN_SAFE_INTEGER;
    let temp = 0;
    for(let right=0; right<nums.length; right++){
        temp += nums[right];
        result = Math.max(result, temp);
        while(temp<0){
            temp -= nums[left];
            left++;
        }
    }
    return result;
};
```

#### [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/description/)
```javascript
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let i = m-1, j = n-1;
    let p = nums1.length-1;
    // 原地修改nums1，所以从后面开始移动
    while(p>0&&j>=0&&i>=0){
        if(nums1[i] >= nums2[j]){
            nums1[p] = nums1[i]
            i--;
        }
        else{
            nums1[p] = nums2[j]
            j--;
        }
        p--;
    }
    //如果nums2还有的话，要把nums2剩下的加进去
    //nums1如果有剩下的，本来就在数组中
    while(j >= 0){
        nums1[p] = nums2[j];
        j--;
        p--;
    }
};
```

#### [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/description/)
```javascript
var compareVersion = function(version1, version2) {
    const v1 = version1.split('.');
    const v2 = version2.split('.');
    for (let i = 0; i < v1.length || i < v2.length; ++i) {
        let x = 0, y = 0;
        if (i < v1.length) {
            x = parseInt(v1[i]);
        }
        if (i < v2.length) {
            y = parseInt(v2[i]);
        }
        if (x > y) {
            return 1;
        }
        if (x < y) {
            return -1;
        }
    }
    return 0;
};
```

#### [BM17. 二分查找-I](https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b?tpId=295&tqId=1499549&ru=%2Fpractice%2F2b317e02f14247a49ffdbdba315459e7&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function search(nums, target) {
    let low = 0
    let high = nums.length-1
    if(!nums.length)return -1
    while(low<=high){// 注意<=
        mid = Math.floor((low+high)/2)// 注意取整
        if(nums[mid] < target){
            low = mid+1 
        }
        else if(nums[mid] > target){
            high = mid-1
        }
        else{
            return mid
        }
    }
    return -1// 其他情况返回-1
}
```
#### [BM19. 寻找峰值](https://www.nowcoder.com/practice/fcf87540c4f347bcb4cf720b5b350c76?tpId=295&tqId=2227748&ru=%2Fpractice%2Fd3df40bd23594118b57554129cadf47b&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page)
```javascript
function findPeakElement( nums ) {
    let left = 0
    let right = nums.length-1
    // 可以看成寻找极大值
    while(left<right){
        let mid=left + Math.floor((right-left)/2);// 防溢出
        if(nums[mid]<nums[mid+1]){// nums[mid+1]大
            left = mid+1
        }
        else{
            right = mid
        }
    }
    return left
}
```